---
title: "Botulinum"
author: "Kellie Ottoboni"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---


## Vignette Info

A detailed description of the botulinum study is provided on p 369-370 in the text. This is a multivariate case-control study with missing data and repeated measures. The aim of the study is to assess the effect of botulinum, that is expected to have opposite effects on the set of variables considered (i.e. we consider one-sided alternatives on each variable). We consider the difference $D$ between observations at time $t_k$, $k=1,2,3$ and the observations at time $t_0$. We may organize data in a $n\times p \times 3$ matrix, so the third dimension contains the differences $D_{ijk}$ related to the $i$th subject on the $j$th variable at time $k$. This will be useful when a repeated measure analysis will be considered.

To begin with we read the data, collect informations about samples (`paz`) and time (`Time`), then we extract the relevant columns. The vector `treatment` is an indicator for whether the patient received botox (`1`) or not (`0`).

```{r setup}
library(permuter)
data(botulinum)
set.seed(100)

n <- length(unique(botulinum[, 1]))
p <- ncol(botulinum) - 4
## Old
paz <- ifelse(botulinum[, 4] == "botox", 1, 2)[1:20]
Time <- botulinum$Time + 1

treatment <- ifelse(botulinum$farmaco == "botox", 1, 0)[1:20]
time <- botulinum$Time + 1


botulinum <- botulinum[, -c(1:4)]

 


```

We abstract the testing problem: a $V$-dimensional non-degenerate variable is observed at $k$ different times on $n$ units in two experimental situations, corresponding to two levels of a symbolic treatment. In our study, $V=24, k=4, n_0 = n_1 = 10$, and $n = 20$. It is worth noting that in this longitudinal study there is a main obstacle to applying classic parametric tests: the number of observed variables at different time points is much higher than the number of subjects ($V \cdot k \gg n$). Furthermore, since all variables may be informative for differentiating two groups, the NPC approach properly applies when analyzing these data. Classic parametric tests or even rank tests in such situations may fail to take into account the dependence structure across variables and time points.

The whole data set is denoted by:
$$
\begin{aligned}
\mathbf{X}  &= \{ X_{hji}(t), t=1, \dots, k, i=1,\dots,n_j, j=0,1, h=1,\dots,V\} \\
            &= \{X_{hji}, i=1,\dots,n_j, j=0,1, h=1,\dots,V\}
\end{aligned}
$$
where $\mathbf{X}_{hji} = \{ X_{hji}(t), t = 1,\dots,k\}$.

In order to account for different baseline observations, assumed to have the role of covariates, the $k - 1$ $V$-dimensional differences $D_{hji}(t) = X_{hji}(1) - X_{hji}(t), t = 2,\dots,k, i = 1,\dots,n_j, j = 0,1, h = 1,\dots,V$ are considered in the analysis. Hence the hypothesis testing problem related to the $h$th variable may be formalized as

$$H_{0h}: \left\lbrace \cap_{t=2}^k \left[ D_{h0}(t) \,{\buildrel d \over =}\, D_{h1}(t)\right] \right\rbrace = \left\lbrace \cap_{t=2}^k H_{0ht}\right\rbrace, h=1,\dots,V$$
against the alternative:
$$H_{1h}: \left\lbrace \cup_{t=2}^k H_{1ht}\right\rbrace, h=1,\dots,V,$$

where $H_{1ht}: \left[ D_{h0}(t) \,{\buildrel d \over >}\,D_{h1}(t)\right]$ or $\left[ D_{h0}(t) \,{\buildrel d \over <}\, D_{h1}(t)\right]$ according to
which kind of stochastic dominance is of interest for the $h$th variable. The alternative hypothesis is that patients treated with the botulinum toxin had lower values than those treated with the placebo ("less than" alternative), except for variables: ME, Mas, Maf, Mp, Mll, Mlr, E, and T, where the placebo group is expected to have lower values than the toxin group ("greater than" alternative). We encode these alternative hypotheses in the vector `alternatives`.

```{r alternatives}
colnames(botulinum)
# greater_than <- c('ME', 'Mas', 'Maf', 'Mp', 'Mll', 'Mlr', 'E', 'T') # These
# don't match the column names in botulinum!!
greater_than <- c("Mas", "Maf", "Mp", "Mld", "Mls")  # I've modified it to match what the original code actually does
alternatives <- ifelse(colnames(botulinum) %in% greater_than, "greater", "less")

 


```

## First Analysis


Now we put the record of each subject in an $n\times p$ matrix and put these matrices in a list. Each element of the list corresponds to a different time point. Afterwards we obtain the differences $D_{ijk}$ with respect to time zero observations and remove the vector of observations at $t_0$ (`D[[1]]`).

```{r diffs}
D <- list()
for (t in 1:4) {
    D[[t]] <- botulinum[time == t, ]
}

# Take differences, Tj - T0
for (t in 2:4) {
    D[[t]] <- D[[t]] - D[[1]]
}
D <- D[-1]

 


```

We first assess the effect of botulinum by performing a two-sample test with repeated measure. This requires to modify the test statistic according to the number of non-missing observations. Since the distribution of non-missing observations varies between variables, we must consider one variable at time. The vector `o` is the indicator function (missing/not missing) applied to each variable and the vector `nu` contains the number of non-missing observations in the two samples. The previous vectors are related to each variable at each time and are not saved outside of the loops. The test statistic for the $j$th variable is: $T_j = \sum^3_{k=1}[\omega_j D_{1jk} - \omega_j D_{0jk} ]$, where $\omega_j = \sqrt{\nu_{0j}/\nu_{1j}}$ . Note that we have already combined, for sake of simplicity, the repeated measure information with the direct
combination (sum).
```{r analysis}
B <- 10
tst <- rep(0, p)
for (j in 1:p) {
    for (t in 1:3) {
        group1 <- D[[t]][treatment == 1, ]
        group0 <- D[[t]][treatment == 0, ]
        o <- ifelse(is.na(D[[t]][, j]), 0, 1)  # indicator for missing data
        nu <- table(o, treatment)
        if (nrow(nu) > 1) {
            nu <- nu[2, ]
        }
        omega <- sqrt(nu[2]/nu[1])
        tst[j] <- tst[j] + omega * (mean(group1[, j], na.rm = TRUE) - mean(group0[, 
            j], na.rm = TRUE))
    }
}

 


```

Under the null hypothesis of no effect of botox, `treatment` is essentially a meaningless label and so the treatment assignments are exchangeable. In order to obtain the null distribution, we permute observations in the usual way, i.e. by randomly exchanging the rows of `botulinum`. This ensures that the inner dependencies among variables and due to the repeated mesures are maintained.
```{r more}
distr <- matrix(0, ncol = p, nrow = B)
for (b in 1:B) {
    perm <- sample(1:n)
    D_star <- lapply(D, function(x) x[perm, ])
    for (j in 1:p) {
        for (t in 1:3) {
            group1 <- D_star[[t]][treatment == 1, ]
            group0 <- D_star[[t]][treatment == 0, ]
            o <- ifelse(is.na(D_star[[t]][, j]), 0, 1)  # indicator for missing data
            nu <- table(o, treatment)
            if (nrow(nu) > 1) {
                nu <- nu[2, ]
            }
            omega <- sqrt(nu[2]/nu[1])
            distr[b, j] <- distr[b, j] + omega * (mean(group1[, j], na.rm = TRUE) - 
                mean(group0[, j], na.rm = TRUE))
        }
    }
}

 


```

We obtain the raw p-values using `t2p` and then adjust for multiplicity using `fwe_minp` with Tippett's combining function.
```{r moremore}
partial_pvalues <- sapply(1:p, function(j) t2p(tst[j], distr[, j], alternatives[j]))
adjusted_pvalues <- fwe_minp(partial_pvalues, distr, combine = "tippett")
res <- data.frame(colnames(botulinum), partial_pvalues, adjusted_pvalues)
colnames(res) <- c("Variable", "Raw p-values", "Adjusted p-values")
library(knitr)
kable(res)



 


```

## Second Analysis

In contrast to the first analysis, we focus on only on the individuals who received botox and look at the differences between measurements at each time point. 

**NB: there is no description of this analysis anywhere. Not sure what is being tested.**
```{r seconddiffs}

D <- array(0, dim = c(n, p, 4))

for (t in 1:4) {
    D[, , t] <- as.matrix(botulinum[Time == t, ])
}

### differences T_j-T_{j-1}

for (t in 2:4) {
    D[, , t] <- D[, , t] - D[, , (t - 1)]
}

D <- D[, , -1]



DB <- D[paz == 1, , ]
n <- dim(DB)[1]

############################################################################## NEW Take differences over time for individuals who received botox
D_new <- list()
for (t in 1:4) {
    D_new[[t]] <- botulinum[time == t & treatment == 1, ]
}

# Take differences, T_j-T_{j-1}
for (t in 2:4) {
    D_new[[t]] <- D_new[[t]] - D_new[[t - 1]]
}
D_botox <- D_new[-1]
n <- nrow(D_botox[[1]])
############################################################################# END NEW

 


```


The test statistic we use is $T_j = \sum_{k=1}^3 \left( S_{jk} \sqrt{ \frac{ \sum_{i\neq k} \nu_i}{\nu_k}} - (\sum_{i=1}^3 S_{ji}-S_{jk})\sqrt{ \frac{ \sum_{i\neq k} \nu_i}{\nu_k}}\right)^2$ where $S_{jk}$ is the sum of non-missing differences for the $j$th variable at the $k$th difference in times and $\nu_k$ is the number of missing values for the $j$th variable at the $k$th difference in times.

```{r secondanalysis}
# Old method
B <- 1000
T <- array(0, dim = c((B + 1), p))
n <- 10

for (j in 1:p) {
    
    Y <- DB[, j, ]
    O <- apply(Y, 2, function(x) {
        ifelse(is.na(x), 0, 1)
    })
    Y <- ifelse(is.na(DB[, j, ]), 0, DB[, j, ])
    
    nu <- apply(O, 2, sum)
    S <- apply(Y, 2, sum)
    
    for (t in 1:3) {
        
        T[1, j] <- T[1, j] + (S[t] * sqrt(sum(nu[-t])/nu[t]) - (sum(S) - S[t]) * 
            sqrt(sum(nu[-t])/nu[t]))^2
        
    }
}  #end p



for (bb in 2:(B + 1)) {
    
    D.star <- apply(DB, c(1, 2), sample)
    D.star <- aperm(D.star, c(2, 3, 1))
    for (j in 1:p) {
        
        Y <- D.star[, j, ]
        O <- apply(Y, 2, function(x) {
            ifelse(is.na(x), 0, 1)
        })
        Y <- ifelse(is.na(D.star[, j, ]), 0, D.star[, j, ])
        
        nu <- apply(O, 2, sum)
        S <- apply(Y, 2, sum)
        for (t in 1:3) {
            
            T[bb, j] <- T[bb, j] + (S[t] * sqrt(sum(nu[-t])/nu[t]) - (sum(S) - S[t]) * 
                sqrt(sum(nu[-t])/nu[t]))^2
            
        }
    }  #end p
    
}


P <- t2p_old(T)

P[1, ]

 


```
**Not sure if this is right -- the p-values don't match at the end, but I can't find an issue with the math**

```{r secondanalysis-new}
############################################################################# NEW
tst <- rep(0, p)
for (j in 1:p) {
    Y <- sapply(D_botox, function(x) x[, j])
    nu <- apply(Y, 2, function(x) sum(!is.na(x)))
    S <- apply(Y, 2, sum, na.rm = TRUE)
    
    for (t in 1:3) {
        tst[j] <- tst[j] + (S[t] * sqrt(sum(nu[-t])/nu[t]) - (sum(S) - S[t]) * sqrt(sum(nu[-t])/nu[t]))^2
        # tst[j] <- tst[j] + (sum(nu[-t])/nu[t])*(2*S[t]-sum(S))^2 # Equivalent, fewer
        # calculations
    }
}

time_ints <- rep(1:3, each = n)
D_temp <- do.call(rbind, D_botox)  # combine the 3 matrices into one
distr <- matrix(0, nrow = B, ncol = p)
for (bb in 1:B) {
    # time_ints <- sample(time_ints) # permute the times: under the null, the
    # distributions for each are equal
    D_star <- apply(D_temp, 2, sample)  # permute within columns, break the correlation within columns
    D_star <- split(data.frame(D_star), time_ints)  # break up the combined data into 3 random matrices of equal size, preserving rows
    for (j in 1:p) {
        Y <- sapply(D_star, function(x) x[, j])
        nu <- apply(Y, 2, function(x) sum(!is.na(x)))
        S <- apply(Y, 2, sum, na.rm = TRUE)
        for (t in 1:3) {
            distr[bb, j] <- distr[bb, j] + (S[t] * sqrt(sum(nu[-t])/nu[t]) - (sum(S) - 
                S[t]) * sqrt(sum(nu[-t])/nu[t]))^2  #+ (sum(nu[-t])/nu[t])*(2*S[t]-sum(S))^2 # Equivalent, fewer calculations       
        }
    }
}

raw_pvalues <- sapply(1:p, function(j) t2p(tst[j], distr[, j], alternative = "greater"))

############################################################################# END NEW

kable(cbind(raw_pvalues, `old method p-values` = P[1, ]), row.names = FALSE)


 


```